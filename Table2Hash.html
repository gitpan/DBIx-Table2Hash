<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>C&lt;DBIx::Table2Hash&gt; - Read a database table into a hash</title>
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">Synopsis</a></li>
	<li><a href="#description">Description</a></li>
	<li><a href="#distributions">Distributions</a></li>
	<li><a href="#constructor_and_initialization">Constructor and initialization</a></li>
	<li><a href="#method:_new(...)">Method: <code>new(...)</code></a></li>
	<li><a href="#method:_select(%parameter)">Method: <code>select(%parameter)</code></a></li>
	<li><a href="#method:_select_hashref(%parameter)">Method: <code>select_hashref(%parameter)</code></a></li>
	<li><a href="#method:_select_tree(%parameter)">Method: <code>select_tree(%parameter)</code></a></li>
	<li><a href="#dbix::table2hash_and_cgi::explorer">DBIx::Table2Hash and CGI::Explorer</a></li>
	<li><a href="#required_modules">Required Modules</a></li>
	<li><a href="#changes">Changes</a></li>
	<li><a href="#faq">FAQ</a></li>
	<li><a href="#author">Author</a></li>
	<li><a href="#copyright">Copyright</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p><code>DBIx::Table2Hash</code> - Read a database table into a hash</p>
<p>
</p>
<hr />
<h1><a name="synopsis">Synopsis</a></h1>
<pre>
        #!/usr/bin/perl</pre>
<pre>
        use DBIx::Table2Hash;</pre>
<pre>
        my($key2value) = DBIx::Table2Hash -&gt; new
        (
                dbh           =&gt; $dbh,
                table_name    =&gt; $table_name,
                key_column    =&gt; 'name',
                value_column  =&gt; 'id'
        ) -&gt; select();</pre>
<pre>
        # or</pre>
<pre>
        my($key2hashref) = DBIx::Table2Hash -&gt; new
        (
                dbh           =&gt; $dbh,
                table_name    =&gt; $table_name,
                key_column    =&gt; 'name',
        ) -&gt; select_hashref();</pre>
<pre>
        # or</pre>
<pre>
        my($key2tree) = DBIx::Table2Hash -&gt; new
        (
                dbh           =&gt; $dbh,
                table_name    =&gt; $table_name,
                key_column    =&gt; 'name',
                child_column  =&gt; 'id',
                parent_column =&gt; 'parent_id',
                skip_columns  =&gt; ['code']
        ) -&gt; select_tree();</pre>
<p>
</p>
<hr />
<h1><a name="description">Description</a></h1>
<p><code>DBIx::Table2Hash</code> is a pure Perl module.</p>
<p>This module reads a database table and stores keys and values in a hash.</p>
<p>The aim is to create a hash which is a simple look-up table. To this end, the module allows the key_column to point to
an SQL expression.</p>
<p><code>select()</code> and <code>select_hashref()</code> do not nest the hash in any way.</p>
<p><code>select_tree()</code> returns a nested hash. <code>select_tree()</code> will call <code>select_hashref()</code> if necessary, ie
if you have not called <code>select_hashref()</code> first.</p>
<p>
</p>
<hr />
<h1><a name="distributions">Distributions</a></h1>
<p>This module is available both as a Unix-style distro (*.tgz) and an
ActiveState-style distro (*.ppd). The latter is shipped in a *.zip file.</p>
<p>See <a href="http://savage.net.au/Perl-modules.html">http://savage.net.au/Perl-modules.html</a> for details.</p>
<p>See <a href="http://savage.net.au/Perl-modules/html/installing-a-module.html">http://savage.net.au/Perl-modules/html/installing-a-module.html</a> for
help on unpacking and installing each type of distro.</p>
<p>
</p>
<hr />
<h1><a name="constructor_and_initialization">Constructor and initialization</a></h1>
<p><code>new(...)</code> returns a <code>DBIx::Table2Hash</code> object.</p>
<p>This is the class's contructor.</p>
<p>Parameters:</p>
<p>Note: These parameters are not checked until you call <code>select_*()</code>, which means the parameters can be passed
in to <code>new()</code>, <code>select_*()</code>, or both.</p>
<ul>
<li></li>
dbh
<p>A database handle.</p>
<p>This parameter is mandatory.</p>
<p></p>
<li></li>
table_name
<p>The name of the table to select from.</p>
<p>This parameter is mandatory.</p>
<p></p>
<li></li>
key_column
<p>When calling <code>select()</code>, <code>select_hashref()</code> and <code>select_tree()</code>, this is the name of the database column,
or the SQL expression, to use for hash keys.</p>
<p>Say you have 2 columns, called col_a and col_b. Then you can concatenate them with:</p>
<p>key_column =&gt; 'concat(col_a, col_b)'</p>
<p>or, even fancier,</p>
<p>key_column =&gt; ``concat(col_a, '-', col_b)''</p>
<p>This parameter is mandatory.</p>
<p></p>
<li></li>
child_column
<p>When calling <code>select_tree()</code>, this is the name of the database column which, combined with the
parent_column column, defines the relationship between nodes and their children.</p>
<p>This parameter is mandatory if you call <code>select_tree()</code>, and ignored if you call <code>select()</code> or
<code>select_hashref()</code>.</p>
<p></p>
<li></li>
parent_column
<p>When calling <code>select_tree()</code>, this is the name of the database column which, combined with the
child_column column, defines the relationship between nodes and their children.</p>
<p>This parameter is mandatory if you call <code>select_tree()</code>, and ignored if you call <code>select()</code> or
<code>select_hashref()</code>.</p>
<p></p>
<li></li>
value_column
<p>The name of the database column to use for hash values.</p>
<p>This parameter is mandatory if you call <code>select()</code>, and ignored if you call <code>select_hashref()</code> or
<code>select_tree()</code>.</p>
<p></p>
<li></li>
where
<p>The optional where clause, including the word 'where', to add to the select.</p>
<p></p>
<li></li>
skip_columns
<p>An array ref of column names to ignore when reading the database table.</p>
<p>It defaults to [].</p>
<p>This parameter is optional.</p>
<p></p></ul>
<p>
</p>
<hr />
<h1><a name="method:_new(...)">Method: <code>new(...)</code></a></h1>
<p>Returns a object of type <code>DBIx::Table2Hash</code>.</p>
<p>See above, in the section called 'Constructor and initialization'.</p>
<p>
</p>
<hr />
<h1><a name="method:_select(%parameter)">Method: <code>select(%parameter)</code></a></h1>
<p>Returns a hash ref.</p>
<p>Each key in the hash points to a single value.</p>
<p>Named parameters, as documented above, can be passed in to this method.</p>
<p>Calling <code>select()</code> actually executes the SQL select statement, and builds the hash.</p>
<p>The demo program test-table2hash.pl, in the examples/ directory, calls <code>select()</code>.</p>
<p>
</p>
<hr />
<h1><a name="method:_select_hashref(%parameter)">Method: <code>select_hashref(%parameter)</code></a></h1>
<p>Returns a hash ref.</p>
<p>Each key in the hash points to a hashref.</p>
<p>Named parameters, as documented above, can be passed in to this method.</p>
<p>Calling <code>select_hashref()</code> actually executes the SQL select statement, and builds the hash.</p>
<p>The demo program test-table2hash.pl, in the examples/ directory, calls <code>select_hashref()</code>.</p>
<p>
</p>
<hr />
<h1><a name="method:_select_tree(%parameter)">Method: <code>select_tree(%parameter)</code></a></h1>
<p>Returns a hash ref.</p>
<p>Each key in the hash points to a hashref.</p>
<p>Named parameters, as documented above, can be passed in to this method.</p>
<p>Calling <code>select_tree()</code> automatically calls <code>select_hashref()</code>, if you have not already called
<code>select_hashref()</code>.</p>
<p>The demo program test-table2tree.pl, in the examples/ directory, calls <code>select_tree()</code>.</p>
<p>
</p>
<hr />
<h1><a name="dbix::table2hash_and_cgi::explorer">DBIx::Table2Hash and CGI::Explorer</a></h1>
<p>The method <code>select_tree()</code> can obviously return a hash with multiple keys at the root level, depending on
the contents of the database table.</p>
<p>Such a hash cannot be passed in to CGI::Explorer V 2.00+. Here's a way around this restriction: Create, on
the fly, a hash key which is The Mother of All Roots. Eg:</p>
<pre>
        my($t2h)  = DBIx::Table2Hash -&gt; new(...);
        my($tree) = $t2h -&gt; select_tree(...);
        my($exp)  = CGI::Explorer -&gt; new(...) -&gt; from_hash(hashref =&gt; {OneAndOnly =&gt; $tree});</pre>
<p>
</p>
<hr />
<h1><a name="required_modules">Required Modules</a></h1>
<p>Only those shipped with Perl.</p>
<p>
</p>
<hr />
<h1><a name="changes">Changes</a></h1>
<p>See Changes.txt.</p>
<p>
</p>
<hr />
<h1><a name="faq">FAQ</a></h1>
<p>Q: What is the point of this module?</p>
<p>A 1: To be able to restore a hash from a database rather than from a file.</p>
<p>A 2: To be able to construct, from a database table, a hash suitable for passing in to CGI::Explorer V 2.00.</p>
<p>Q: Can your other module <code>DBIx::Hash2Table</code> be used to save the hash back to the database?</p>
<p>A: Sure.</p>
<p>Q: Do you ship demos for the 3 methods <code>select()</code>, <code>select_hashref()</code> and <code>select_tree()</code>?</p>
<p>A: Yes. See the examples/ directory.</p>
<p>If you installed this module locally via ppm, look in the x86/ directory for the file to unpack.</p>
<p>If you installed this module remotely via ppm, you need to download and unpack the distro itself.</p>
<p>Q: Are there any other modules with similar capabilities?</p>
<p>A: Yes:</p>
<ul>
<li></li>
<code>DBIx::Lookup::Field</code>
<p>Quite similar.</p>
<p></p>
<li></li>
<code>DBIx::TableHash</code>
<p>This module takes a very long set of parameters, but unfortunately does not take a database handle.</p>
<p>It does mean the module, being extremely complex, can read in more than one column as the value of a hash key, and it
has caching abilities too.</p>
<p>It works by tieing a hash to an MySQL table, and hence supports writing to the table. It uses MySQL-specific code,
for example, when it locks tables.</p>
<p>Unfortunately, it does not use data binding, so it cannot handle data which contains single quotes!</p>
<p>Further, it uses /^\w+$/ to 'validate' column names, so it cannot accept an SQL expression instead of a column name.</p>
<p>Lastly, it also uses /^\w+$/ to 'validate' table names, so it cannot accept table names and views containing spaces
and other 'funny' characters, eg '&amp;' (both of which I have to deal with under MS Access).</p>
<p></p>
<li></li>
<code>DBIx::Tree</code>
<p>This module was the inspiration for <code>select_tree()</code>.</p>
<p>As it reads the database table it calls a call-back sub, which you use to process the rows of the table.</p>
<p></p></ul>
<p>
</p>
<hr />
<h1><a name="author">Author</a></h1>
<p><code>DBIx::Table2Hash</code> was written by Ron Savage <em>&lt;<a href="mailto:ron@savage.net.au">ron@savage.net.au</a>&gt;</em> in 2003.</p>
<p>Home page: <a href="http://savage.net.au/index.html">http://savage.net.au/index.html</a></p>
<p>
</p>
<hr />
<h1><a name="copyright">Copyright</a></h1>
<p>Australian copyright (c) 2003, Ron Savage. All rights reserved.</p>
<pre>
        All Programs of mine are 'OSI Certified Open Source Software';
        you can redistribute them and/or modify them under the terms of
        The Artistic License, a copy of which is available at:
        <a href="http://www.opensource.org/licenses/index.html">http://www.opensource.org/licenses/index.html</a></pre>

</body>

</html>
